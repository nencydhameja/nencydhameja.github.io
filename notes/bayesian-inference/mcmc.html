<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Markov Chain Monte Carlo – Introduction to Bayesian Thinking</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-d279e387f5997211c97d65d1670dc95e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<meta name="shinylive:serviceworker_dir" content=".">
<script src="site_libs/quarto-contrib/shinylive-0.9.1/shinylive/load-shinylive-sw.js" type="module"></script>
<script src="site_libs/quarto-contrib/shinylive-0.9.1/shinylive/run-python-blocks.js" type="module"></script>
<link href="site_libs/quarto-contrib/shinylive-0.9.1/shinylive/shinylive.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/shinylive-quarto-css/shinylive-quarto.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./mcmc.html">Beyond Conjugates</a></li><li class="breadcrumb-item"><a href="./mcmc.html">MCMC</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Introduction to Bayesian Thinking</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./bayes-theorem.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bayes’ Theorem</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./priors-posteriors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Priors &amp; Posteriors</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./shrinkage.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Shrinkage</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./bayes-vs-freq.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bayesian vs Frequentist</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Beyond Conjugates</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./mcmc.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">MCMC</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./hierarchical.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Hierarchical Models</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./bayesian-regression.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bayesian Regression</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#what-is-mcmc" id="toc-what-is-mcmc" class="nav-link active" data-scroll-target="#what-is-mcmc">What is MCMC?</a>
  <ul class="collapse">
  <li><a href="#watch-it-happen" id="toc-watch-it-happen" class="nav-link" data-scroll-target="#watch-it-happen">Watch it happen</a></li>
  </ul></li>
  <li><a href="#why-do-we-need-it" id="toc-why-do-we-need-it" class="nav-link" data-scroll-target="#why-do-we-need-it">Why do we need it?</a></li>
  <li><a href="#the-metropolis-hastings-algorithm" id="toc-the-metropolis-hastings-algorithm" class="nav-link" data-scroll-target="#the-metropolis-hastings-algorithm">The Metropolis-Hastings algorithm</a>
  <ul class="collapse">
  <li><a href="#simulation-1-metropolis-hastings-in-action" id="toc-simulation-1-metropolis-hastings-in-action" class="nav-link" data-scroll-target="#simulation-1-metropolis-hastings-in-action">Simulation 1: Metropolis-Hastings in action</a></li>
  <li><a href="#things-to-try" id="toc-things-to-try" class="nav-link" data-scroll-target="#things-to-try">Things to try</a></li>
  </ul></li>
  <li><a href="#burn-in-and-convergence" id="toc-burn-in-and-convergence" class="nav-link" data-scroll-target="#burn-in-and-convergence">Burn-in and convergence</a>
  <ul class="collapse">
  <li><a href="#simulation-2-multiple-chains-and-convergence" id="toc-simulation-2-multiple-chains-and-convergence" class="nav-link" data-scroll-target="#simulation-2-multiple-chains-and-convergence">Simulation 2: Multiple chains and convergence</a></li>
  <li><a href="#things-to-try-1" id="toc-things-to-try-1" class="nav-link" data-scroll-target="#things-to-try-1">Things to try</a></li>
  </ul></li>
  <li><a href="#the-key-message" id="toc-the-key-message" class="nav-link" data-scroll-target="#the-key-message">The key message</a></li>
  <li><a href="#did-you-know" id="toc-did-you-know" class="nav-link" data-scroll-target="#did-you-know">Did you know?</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./mcmc.html">Beyond Conjugates</a></li><li class="breadcrumb-item"><a href="./mcmc.html">MCMC</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Markov Chain Monte Carlo</h1>
</div>



<div class="quarto-title-meta column-body">

    
  
    
  </div>
  


</header>


<section id="what-is-mcmc" class="level2">
<h2 class="anchored" data-anchor-id="what-is-mcmc">What is MCMC?</h2>
<p>The name breaks down into two parts:</p>
<ul>
<li><strong>Monte Carlo:</strong> using random sampling to approximate something you can’t compute exactly. Instead of solving an integral analytically, you draw random samples and use their average as an approximation. (Named after the Monte Carlo casino — it’s fundamentally about randomness.)</li>
<li><strong>Markov Chain:</strong> a sequence of random values where each value depends only on the previous one — not on the full history. The “chain” is a random walk through parameter space, where each step proposes a new value based on where you currently are.</li>
</ul>
<p>Put them together: <strong>MCMC constructs a Markov chain whose long-run distribution equals the posterior.</strong> Run it long enough, and the samples you collect are (approximately) draws from <span class="math inline">\(p(\theta \mid y)\)</span> — even though you never computed that distribution directly.</p>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>The blindfolded hiker.</strong> Imagine you’re blindfolded on a hilly landscape and want to map out the shape of a mountain. You can’t see the whole thing, but at each step you can feel whether the ground goes up or down. You take a step — if it’s uphill (higher probability), you go. If it’s downhill, you <em>might</em> go (sometimes you need to cross valleys to find higher peaks). After thousands of steps, plot everywhere you’ve been on a map — the places you visited most often are the peaks. You’ve mapped the mountain without ever seeing it. That’s MCMC.</p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Isn’t this just optimization?</strong> It looks like it — both climb hills. But an optimizer (like maximum likelihood in Stata’s <code>reg</code>) only goes uphill, finds the <strong>peak</strong>, and stops. That gives you one number: the best <span class="math inline">\(\hat\beta\)</span>. MCMC deliberately goes downhill sometimes (step 4 above: accepting worse proposals with some probability). That’s what lets it explore the full shape of the posterior — not just <em>where</em> the peak is, but how wide, how skewed, and whether there are multiple peaks. Turn off the downhill moves and you’d have a hill-climbing optimizer. Keep them on and you have a sampler.</p>
</div>
</div>
</div>
<section id="watch-it-happen" class="level3">
<h3 class="anchored" data-anchor-id="watch-it-happen">Watch it happen</h3>
<p>The chain wanders through parameter space. Early on, the histogram of visited values looks nothing like the target. But as samples accumulate, the histogram converges to the true posterior — the chain has “learned” the distribution just by random walking.</p>
<pre class="shinylive-r" data-engine="r"><code>#| standalone: true
#| viewerHeight: 480

library(shiny)

ui &lt;- fluidPage(
  tags$head(tags$style(HTML("
    .stats-box {
      background: #f0f4f8; border-radius: 6px; padding: 14px;
      margin-top: 8px; font-size: 13px; line-height: 1.7;
    }
    .stats-box b { color: #2c3e50; }
    .good { color: #27ae60; font-weight: bold; }
  "))),

  sidebarLayout(
    sidebarPanel(
      width = 3,

      sliderInput("show_n", "Samples to show:",
                  min = 10, max = 5000, value = 50, step = 10,
                  animate = animationOptions(interval = 80, loop = FALSE)),

      actionButton("go_intro", "New chain", class = "btn-primary", width = "100%"),

      uiOutput("results_intro")
    ),

    mainPanel(
      width = 9,
      fluidRow(
        column(6, plotOutput("trace_intro", height = "340px")),
        column(6, plotOutput("hist_intro", height = "340px"))
      )
    )
  )
)

server &lt;- function(input, output, session) {

  chain_data &lt;- reactive({
    input$go_intro

    # Target: posterior is N(2, 0.5^2) — we pretend we can't compute this
    target_mu &lt;- 2
    target_sd &lt;- 0.5
    log_target &lt;- function(x) dnorm(x, target_mu, target_sd, log = TRUE)

    # Run a long chain once
    n_total &lt;- 5000
    chain &lt;- numeric(n_total)
    chain[1] &lt;- -1  # start far from the target
    prop_sd &lt;- 0.4

    for (t in 2:n_total) {
      proposal &lt;- rnorm(1, chain[t - 1], prop_sd)
      log_r &lt;- log_target(proposal) - log_target(chain[t - 1])
      if (log(runif(1)) &lt; log_r) {
        chain[t] &lt;- proposal
      } else {
        chain[t] &lt;- chain[t - 1]
      }
    }

    list(chain = chain, target_mu = target_mu, target_sd = target_sd)
  })

  output$trace_intro &lt;- renderPlot({
    d &lt;- chain_data()
    n_show &lt;- min(input$show_n, length(d$chain))
    par(mar = c(4, 4.5, 3, 1))

    plot(1:n_show, d$chain[1:n_show], type = "l",
         col = "#3498db80", lwd = 0.6,
         xlim = c(1, max(200, n_show)),
         ylim = range(d$chain),
         xlab = "Step", ylab = expression(theta),
         main = "The chain explores")

    # Show current position
    points(n_show, d$chain[n_show], pch = 19, col = "#e74c3c", cex = 1.5)

    abline(h = d$target_mu, lty = 2, col = "#27ae60", lwd = 1.5)
    text(max(200, n_show) * 0.95, d$target_mu,
         expression("Target " * mu), pos = 3, cex = 0.8, col = "#27ae60")
  })

  output$hist_intro &lt;- renderPlot({
    d &lt;- chain_data()
    n_show &lt;- min(input$show_n, length(d$chain))
    samples &lt;- d$chain[1:n_show]
    par(mar = c(4, 4.5, 3, 1))

    xlim &lt;- c(d$target_mu - 3 * d$target_sd - 1,
              d$target_mu + 3 * d$target_sd + 1)

    hist(samples, breaks = seq(xlim[1], xlim[2], length.out = 40),
         freq = FALSE, col = "#3498db40", border = "#3498db",
         xlim = xlim, ylim = c(0, 1.2),
         xlab = expression(theta), main = "Histogram vs true posterior")

    # True target
    x_seq &lt;- seq(xlim[1], xlim[2], length.out = 300)
    lines(x_seq, dnorm(x_seq, d$target_mu, d$target_sd),
          col = "#27ae60", lwd = 2.5)

    legend("topright", bty = "n", cex = 0.85,
           legend = c(paste0("MCMC samples (n=", n_show, ")"),
                      "True posterior"),
           col = c("#3498db", "#27ae60"),
           lwd = c(NA, 2.5), pch = c(15, NA), pt.cex = c(1.5, NA))
  })

  output$results_intro &lt;- renderUI({
    d &lt;- chain_data()
    n_show &lt;- min(input$show_n, length(d$chain))
    samples &lt;- d$chain[1:n_show]

    tags$div(class = "stats-box",
      HTML(paste0(
        "&lt;b&gt;Samples:&lt;/b&gt; ", n_show, "&lt;br&gt;",
        "&lt;b&gt;MCMC mean:&lt;/b&gt; ", round(mean(samples), 3), "&lt;br&gt;",
        "&lt;b&gt;True mean:&lt;/b&gt; ", d$target_mu, "&lt;br&gt;",
        "&lt;b&gt;Error:&lt;/b&gt; &lt;span class='good'&gt;",
        round(abs(mean(samples) - d$target_mu), 3), "&lt;/span&gt;"
      ))
    )
  })
}

shinyApp(ui, server)</code></pre>
<p>Drag the slider (or hit the play button) and watch:</p>
<ul>
<li><strong>10 samples:</strong> the histogram is jagged, nothing like the green curve. The chain hasn’t explored enough.</li>
<li><strong>100 samples:</strong> the shape starts to emerge. The chain has found the high-probability region.</li>
<li><strong>1000+ samples:</strong> the histogram matches the true posterior almost exactly. The chain has “learned” the distribution through random walking alone.</li>
</ul>
<p>The chain never knew the formula for the green curve. It only knew how to evaluate the posterior at any single point and compare “is this new spot better or worse?” That’s enough.</p>
</section>
</section>
<section id="why-do-we-need-it" class="level2">
<h2 class="anchored" data-anchor-id="why-do-we-need-it">Why do we need it?</h2>
<p>On the <a href="priors-posteriors.html">Priors &amp; Posteriors</a> page, we used <strong>conjugate priors</strong> — special prior-likelihood pairs where the posterior has a <a href="priors-posteriors.html#the-problem-most-real-models-arent-conjugate">closed-form solution</a>. That’s elegant but limiting. Most real models don’t have conjugate posteriors:</p>
<ul>
<li>Logistic regression with a prior on coefficients</li>
<li>Hierarchical models with multiple levels of parameters</li>
<li>Any model where the posterior <span class="math inline">\(p(\theta \mid y) \propto p(y \mid \theta) \, p(\theta)\)</span> doesn’t simplify to a known distribution</li>
</ul>
<p>For these models, we can’t write down the posterior analytically. We need to <strong>sample from it numerically</strong>. That’s what MCMC does.</p>
</section>
<section id="the-metropolis-hastings-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="the-metropolis-hastings-algorithm">The Metropolis-Hastings algorithm</h2>
<p>The most foundational MCMC algorithm. The core idea is beautifully simple:</p>
<ol type="1">
<li>Start at some value <span class="math inline">\(\theta_0\)</span>.</li>
<li><strong>Propose</strong> a new value <span class="math inline">\(\theta^*\)</span> from a proposal distribution <span class="math inline">\(q(\theta^* \mid \theta_t)\)</span> — typically <span class="math inline">\(\theta^* \sim N(\theta_t, \sigma_{prop}^2)\)</span>.</li>
<li><strong>Compute the acceptance ratio:</strong> <span class="math display">\[\alpha = \min\left(1, \, \frac{p(\theta^* \mid y) \; q(\theta_t \mid \theta^*)}{p(\theta_t \mid y) \; q(\theta^* \mid \theta_t)}\right)\]</span></li>
<li><strong>Accept</strong> <span class="math inline">\(\theta^*\)</span> with probability <span class="math inline">\(\alpha\)</span> (set <span class="math inline">\(\theta_{t+1} = \theta^*\)</span>). Otherwise stay: <span class="math inline">\(\theta_{t+1} = \theta_t\)</span>.</li>
<li>Repeat.</li>
</ol>
<p>When the proposal is symmetric — e.g.&nbsp;<span class="math inline">\(q(\theta^* \mid \theta_t) = N(\theta_t, \sigma_{prop}^2)\)</span> — the proposal ratio <span class="math inline">\(q(\theta_t \mid \theta^*) / q(\theta^* \mid \theta_t) = 1\)</span> and the acceptance ratio simplifies to <span class="math inline">\(\alpha = \min\!\left(1,\; p(\theta^* \mid y) \,/\, p(\theta_t \mid y)\right)\)</span>. This is the original <strong>Metropolis</strong> algorithm. The Hastings (1970) generalization adds the proposal ratio so that asymmetric proposals can be used.</p>
<p><strong>Key insight:</strong> you never need to compute the normalizing constant <span class="math inline">\(p(y) = \int p(y \mid \theta) \, p(\theta) \, d\theta\)</span>. The ratio <span class="math inline">\(p(\theta^* \mid y) / p(\theta_t \mid y)\)</span> cancels it out. You only need to evaluate the <strong>unnormalized posterior</strong> — the numerator of Bayes’ theorem.</p>
<p>After enough iterations, the chain converges to the posterior distribution. The samples <span class="math inline">\(\theta_1, \theta_2, \ldots\)</span> are (correlated) draws from <span class="math inline">\(p(\theta \mid y)\)</span>.</p>
<section id="simulation-1-metropolis-hastings-in-action" class="level3">
<h3 class="anchored" data-anchor-id="simulation-1-metropolis-hastings-in-action">Simulation 1: Metropolis-Hastings in action</h3>
<p>Estimate the mean <span class="math inline">\(\mu\)</span> of normally distributed data with unknown true value. The proposal width controls exploration: too narrow and the chain moves slowly; too wide and most proposals get rejected.</p>
<pre class="shinylive-r" data-engine="r"><code>#| standalone: true
#| viewerHeight: 650

library(shiny)

ui &lt;- fluidPage(
  tags$head(tags$style(HTML("
    .stats-box {
      background: #f0f4f8; border-radius: 6px; padding: 14px;
      margin-top: 12px; font-size: 14px; line-height: 1.9;
    }
    .stats-box b { color: #2c3e50; }
    .good { color: #27ae60; font-weight: bold; }
    .bad  { color: #e74c3c; font-weight: bold; }
  "))),

  sidebarLayout(
    sidebarPanel(
      width = 3,

      sliderInput("true_mu", HTML("True &amp;mu;:"),
                  min = -3, max = 3, value = 1, step = 0.5),

      sliderInput("n_data", "Data points:",
                  min = 5, max = 100, value = 20, step = 5),

      sliderInput("prop_sd", "Proposal width (SD):",
                  min = 0.05, max = 5, value = 0.5, step = 0.05),

      sliderInput("n_iter", "Iterations:",
                  min = 500, max = 5000, value = 2000, step = 500),

      actionButton("go", "Run chain", class = "btn-primary", width = "100%"),

      uiOutput("results")
    ),

    mainPanel(
      width = 9,
      fluidRow(
        column(6, plotOutput("trace_plot", height = "420px")),
        column(6, plotOutput("hist_plot", height = "420px"))
      )
    )
  )
)

server &lt;- function(input, output, session) {

  dat &lt;- reactive({
    input$go
    true_mu  &lt;- input$true_mu
    n_data   &lt;- input$n_data
    prop_sd  &lt;- input$prop_sd
    n_iter   &lt;- input$n_iter
    sigma    &lt;- 2  # known SD

    # Generate data
    y &lt;- rnorm(n_data, mean = true_mu, sd = sigma)

    # Log posterior (unnormalized): normal likelihood + flat prior
    log_post &lt;- function(mu) {
      sum(dnorm(y, mean = mu, sd = sigma, log = TRUE))
    }

    # Metropolis-Hastings
    chain &lt;- numeric(n_iter)
    chain[1] &lt;- 0  # start at 0
    accepted &lt;- 0

    for (t in 2:n_iter) {
      proposal &lt;- rnorm(1, mean = chain[t - 1], sd = prop_sd)
      log_ratio &lt;- log_post(proposal) - log_post(chain[t - 1])

      if (log(runif(1)) &lt; log_ratio) {
        chain[t] &lt;- proposal
        accepted &lt;- accepted + 1
      } else {
        chain[t] &lt;- chain[t - 1]
      }
    }

    accept_rate &lt;- accepted / (n_iter - 1)

    # Analytic posterior for comparison (conjugate: flat prior + normal)
    post_mean &lt;- mean(y)
    post_sd   &lt;- sigma / sqrt(n_data)

    list(chain = chain, accept_rate = accept_rate,
         true_mu = true_mu, post_mean = post_mean, post_sd = post_sd,
         n_iter = n_iter, prop_sd = prop_sd)
  })

  output$trace_plot &lt;- renderPlot({
    d &lt;- dat()
    par(mar = c(4.5, 4.5, 3, 1))

    plot(d$chain, type = "l", col = "#3498db80", lwd = 0.5,
         xlab = "Iteration", ylab = expression(mu),
         main = "Trace Plot")

    abline(h = d$true_mu, lty = 2, col = "#e74c3c", lwd = 2)
    abline(h = d$post_mean, lty = 3, col = "#27ae60", lwd = 2)

    legend("topright", bty = "n", cex = 0.8,
           legend = c(expression("True " * mu),
                      "Posterior mean (analytic)"),
           col = c("#e74c3c", "#27ae60"),
           lty = c(2, 3), lwd = 2)
  })

  output$hist_plot &lt;- renderPlot({
    d &lt;- dat()
    par(mar = c(4.5, 4.5, 3, 1))

    # Discard first 20% as burn-in
    burnin &lt;- floor(d$n_iter * 0.2)
    samples &lt;- d$chain[(burnin + 1):d$n_iter]

    hist(samples, breaks = 40, freq = FALSE,
         col = "#3498db40", border = "#3498db",
         xlab = expression(mu), main = "Posterior Distribution",
         xlim = range(c(samples, d$true_mu - 0.5, d$true_mu + 0.5)))

    # Analytic posterior
    x_seq &lt;- seq(min(samples) - 0.5, max(samples) + 0.5, length.out = 200)
    lines(x_seq, dnorm(x_seq, d$post_mean, d$post_sd),
          col = "#27ae60", lwd = 2.5)

    abline(v = d$true_mu, lty = 2, col = "#e74c3c", lwd = 2)

    legend("topright", bty = "n", cex = 0.8,
           legend = c("MCMC samples", "Analytic posterior",
                      expression("True " * mu)),
           col = c("#3498db", "#27ae60", "#e74c3c"),
           lwd = c(NA, 2.5, 2), lty = c(NA, 1, 2),
           pch = c(15, NA, NA), pt.cex = c(1.5, NA, NA))
  })

  output$results &lt;- renderUI({
    d &lt;- dat()
    burnin &lt;- floor(d$n_iter * 0.2)
    samples &lt;- d$chain[(burnin + 1):d$n_iter]

    rate_class &lt;- if (d$accept_rate &gt; 0.15 &amp;&amp; d$accept_rate &lt; 0.5) "good" else "bad"
    rate_note &lt;- if (d$accept_rate &lt; 0.15) {
      "Too low — proposal too wide"
    } else if (d$accept_rate &gt; 0.5) {
      "Too high — proposal too narrow"
    } else {
      "Good range (0.15-0.50)"
    }

    tags$div(class = "stats-box",
      HTML(paste0(
        "&lt;b&gt;Acceptance rate:&lt;/b&gt; &lt;span class='", rate_class, "'&gt;",
        round(d$accept_rate * 100, 1), "%&lt;/span&gt;&lt;br&gt;",
        "&lt;small&gt;", rate_note, "&lt;/small&gt;&lt;br&gt;",
        "&lt;hr style='margin:8px 0'&gt;",
        "&lt;b&gt;MCMC posterior mean:&lt;/b&gt; ", round(mean(samples), 3), "&lt;br&gt;",
        "&lt;b&gt;Analytic posterior mean:&lt;/b&gt; ", round(d$post_mean, 3), "&lt;br&gt;",
        "&lt;b&gt;True &amp;mu;:&lt;/b&gt; ", d$true_mu, "&lt;br&gt;",
        "&lt;hr style='margin:8px 0'&gt;",
        "&lt;b&gt;Proposal width:&lt;/b&gt; ", d$prop_sd
      ))
    )
  })
}

shinyApp(ui, server)</code></pre>
</section>
<section id="things-to-try" class="level3">
<h3 class="anchored" data-anchor-id="things-to-try">Things to try</h3>
<ul>
<li><strong>Proposal width = 0.5:</strong> a well-tuned chain. The trace plot shows good mixing (bouncing around the posterior), and the histogram matches the analytic posterior (green curve). Acceptance rate is in the sweet spot (20–40%).</li>
<li><strong>Proposal width = 0.05:</strong> too narrow. The chain takes tiny steps — the trace plot shows slow, random-walk behavior. Acceptance rate is near 100% (almost every proposal is accepted because it’s barely different). The chain explores the posterior very slowly.</li>
<li><strong>Proposal width = 5:</strong> too wide. Most proposals jump far from the current value and land in low-probability regions — they get rejected. The trace plot shows long flat stretches (the chain is stuck). Acceptance rate is very low.</li>
<li><strong>The goldilocks principle:</strong> you want a proposal width that’s “just right” — large enough to explore, small enough to get accepted. The theoretical optimum for 1D is an acceptance rate around 44% (Roberts et al., 1997).</li>
</ul>
<hr>
</section>
</section>
<section id="burn-in-and-convergence" class="level2">
<h2 class="anchored" data-anchor-id="burn-in-and-convergence">Burn-in and convergence</h2>
<p>A practical concern: the chain starts at an arbitrary value (<span class="math inline">\(\theta_0 = 0\)</span> above). The early samples reflect the starting point, not the posterior. You need to <strong>discard</strong> these initial samples — the “burn-in” period.</p>
<p><strong>How do you know the chain has converged?</strong> Run multiple chains from different starting points. If they all end up exploring the same region, you have evidence of convergence. If they’re stuck in different places, the chains haven’t converged and you need more iterations.</p>
<section id="simulation-2-multiple-chains-and-convergence" class="level3">
<h3 class="anchored" data-anchor-id="simulation-2-multiple-chains-and-convergence">Simulation 2: Multiple chains and convergence</h3>
<pre class="shinylive-r" data-engine="r"><code>#| standalone: true
#| viewerHeight: 580

library(shiny)

ui &lt;- fluidPage(
  tags$head(tags$style(HTML("
    .stats-box {
      background: #f0f4f8; border-radius: 6px; padding: 14px;
      margin-top: 12px; font-size: 14px; line-height: 1.9;
    }
    .stats-box b { color: #2c3e50; }
    .good { color: #27ae60; font-weight: bold; }
    .bad  { color: #e74c3c; font-weight: bold; }
  "))),

  sidebarLayout(
    sidebarPanel(
      width = 3,

      sliderInput("n_iter2", "Iterations:",
                  min = 200, max = 3000, value = 1000, step = 200),

      sliderInput("burnin", "Burn-in (discard first %):",
                  min = 0, max = 50, value = 20, step = 5),

      sliderInput("prop_sd2", "Proposal width:",
                  min = 0.1, max = 3, value = 0.5, step = 0.1),

      actionButton("go2", "Run chains", class = "btn-primary", width = "100%"),

      uiOutput("results2")
    ),

    mainPanel(
      width = 9,
      plotOutput("multi_trace", height = "420px")
    )
  )
)

server &lt;- function(input, output, session) {

  dat2 &lt;- reactive({
    input$go2
    n_iter  &lt;- input$n_iter2
    burnin  &lt;- input$burnin / 100
    prop_sd &lt;- input$prop_sd2
    sigma   &lt;- 2
    true_mu &lt;- 1.5

    # Generate data once
    y &lt;- rnorm(30, mean = true_mu, sd = sigma)

    log_post &lt;- function(mu) {
      sum(dnorm(y, mean = mu, sd = sigma, log = TRUE))
    }

    # Run 4 chains from different starting points
    starts &lt;- c(-5, -2, 4, 7)
    chain_cols &lt;- c("#e74c3c", "#3498db", "#27ae60", "#f39c12")
    chains &lt;- matrix(0, nrow = n_iter, ncol = 4)

    for (ch in 1:4) {
      chains[1, ch] &lt;- starts[ch]
      for (t in 2:n_iter) {
        proposal &lt;- rnorm(1, chains[t - 1, ch], prop_sd)
        log_r &lt;- log_post(proposal) - log_post(chains[t - 1, ch])
        if (log(runif(1)) &lt; log_r) {
          chains[t, ch] &lt;- proposal
        } else {
          chains[t, ch] &lt;- chains[t - 1, ch]
        }
      }
    }

    # Posterior (analytic)
    post_mean &lt;- mean(y)

    list(chains = chains, starts = starts, chain_cols = chain_cols,
         n_iter = n_iter, burnin = burnin, true_mu = true_mu,
         post_mean = post_mean)
  })

  output$multi_trace &lt;- renderPlot({
    d &lt;- dat2()
    par(mar = c(4.5, 4.5, 3, 1))

    burnin_line &lt;- floor(d$n_iter * d$burnin)

    ylim &lt;- range(d$chains)
    plot(NULL, xlim = c(1, d$n_iter), ylim = ylim,
         xlab = "Iteration", ylab = expression(mu),
         main = "Four Chains from Different Starting Points")

    # Shade burn-in region
    if (burnin_line &gt; 0) {
      rect(0, ylim[1] - 1, burnin_line, ylim[2] + 1,
           col = "#f0f0f080", border = NA)
      abline(v = burnin_line, lty = 2, col = "gray40", lwd = 1.5)
      text(burnin_line, ylim[2], "burn-in", pos = 2,
           cex = 0.8, col = "gray40")
    }

    for (ch in 1:4) {
      lines(d$chains[, ch], col = paste0(d$chain_cols[ch], "90"),
            lwd = 0.8)
    }

    abline(h = d$true_mu, lty = 2, col = "#2c3e50", lwd = 2)
    text(d$n_iter * 0.98, d$true_mu, expression("True " * mu),
         pos = 3, cex = 0.85, col = "#2c3e50")

    legend("topright", bty = "n", cex = 0.75,
           legend = paste0("Chain ", 1:4, " (start = ", d$starts, ")"),
           col = d$chain_cols, lwd = 2)
  })

  output$results2 &lt;- renderUI({
    d &lt;- dat2()
    burnin_n &lt;- floor(d$n_iter * d$burnin)

    # Post-burnin means per chain
    if (burnin_n &lt; d$n_iter) {
      post_samples &lt;- d$chains[(burnin_n + 1):d$n_iter, ]
      chain_means &lt;- round(colMeans(post_samples), 3)
      spread &lt;- round(max(chain_means) - min(chain_means), 3)
    } else {
      chain_means &lt;- rep(NA, 4)
      spread &lt;- NA
    }

    converged &lt;- !is.na(spread) &amp;&amp; spread &lt; 0.3
    conv_class &lt;- if (converged) "good" else "bad"
    conv_label &lt;- if (converged) "Chains agree" else "Chains disagree"

    tags$div(class = "stats-box",
      HTML(paste0(
        "&lt;b&gt;Post-burn-in means:&lt;/b&gt;&lt;br&gt;",
        paste0("Chain ", 1:4, ": ", chain_means, collapse = "&lt;br&gt;"), "&lt;br&gt;",
        "&lt;hr style='margin:8px 0'&gt;",
        "&lt;b&gt;Spread:&lt;/b&gt; &lt;span class='", conv_class, "'&gt;",
        spread, "&lt;/span&gt;&lt;br&gt;",
        "&lt;span class='", conv_class, "'&gt;", conv_label, "&lt;/span&gt;"
      ))
    )
  })
}

shinyApp(ui, server)</code></pre>
</section>
<section id="things-to-try-1" class="level3">
<h3 class="anchored" data-anchor-id="things-to-try-1">Things to try</h3>
<ul>
<li><strong>Default settings (1000 iterations, burn-in = 20%):</strong> all four chains start at different values (-5, -2, 4, 7) but converge to the same region within ~100 iterations. After burn-in, all chain means agree. This is convergence.</li>
<li><strong>Burn-in = 0%:</strong> the early samples (from the starting points) contaminate the posterior. The chain means diverge because each chain’s average is pulled toward its start.</li>
<li><strong>Proposal width = 0.1:</strong> very slow exploration. The chains take longer to converge — you can see them creeping slowly toward the true value. With only 1000 iterations, they might not fully converge. Increase iterations to fix this.</li>
<li><strong>Proposal width = 3:</strong> the chains converge quickly but the trace plot shows many flat stretches (rejected proposals). The posterior is explored but inefficiently.</li>
</ul>
<hr>
</section>
</section>
<section id="the-key-message" class="level2">
<h2 class="anchored" data-anchor-id="the-key-message">The key message</h2>
<p>MCMC lets you compute posteriors for <strong>any</strong> model — not just conjugate ones. Specify the likelihood and the prior, and the algorithm samples from the posterior. This is what makes Bayesian inference practical for real-world problems like <a href="hierarchical.html">hierarchical models</a>, where closed-form posteriors don’t exist.</p>
<p>This is also the engine behind <a href="bayesian-regression.html">Bayesian regression</a>. When you type <code>bayes: reg y x</code> in Stata, it runs Metropolis-Hastings to sample from the posterior over regression coefficients — the same algorithm you just watched above, applied to a model you already know.</p>
<p>Modern tools like <strong>Stan</strong>, <strong>JAGS</strong>, and <strong>PyMC</strong> automate this — you specify the model and they handle the sampling. But understanding the basics (proposal tuning, burn-in, convergence checks) helps you diagnose problems when things go wrong.</p>
<hr>
</section>
<section id="did-you-know" class="level2">
<h2 class="anchored" data-anchor-id="did-you-know">Did you know?</h2>
<ul>
<li><p>The Metropolis algorithm was developed at <strong>Los Alamos National Laboratory</strong> by <strong>Nicholas Metropolis, Arianna Rosenbluth, Marshall Rosenbluth, Augusta Teller, and Edward Teller (1953)</strong> — originally for simulating equations of state in statistical mechanics, not statistics. <strong>W.K. Hastings (1970)</strong> generalized it to asymmetric proposal distributions.</p></li>
<li><p>MCMC was named one of the <strong>top 10 algorithms of the 20th century</strong> by Computing in Science &amp; Engineering (2000). It’s used across physics, chemistry, biology, statistics, and machine learning.</p></li>
<li><p>Modern Bayesian computation has largely moved beyond basic Metropolis-Hastings to <strong>Hamiltonian Monte Carlo (HMC)</strong> and its adaptive variant <strong>NUTS</strong> (Hoffman &amp; Gelman, 2014). HMC uses gradient information to make smarter proposals, dramatically improving efficiency in high-dimensional problems. This is what Stan uses under the hood.</p></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>© 2026 <a href="https://nencydhameja.com">Nency Dhameja</a> | <a href="../index.html">All Notes</a><br><span style="white-space:nowrap">Inspired by my advisor, <a href="https://sites.google.com/site/slichterdavid/home">David Slichter</a> · Developed with AI assistance</span></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>